<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Admin Panel â€” Drivers with Directions (No Socket)</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>

  <!-- QRCode library (used by your UI) -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

  <style>
    :root { --accent: #0078ff; --muted: #7b8aa3; --bg: #f4f7fb; --card-bg: #fff; --success: #2ea44f; --danger: #d73a49; }
    * { box-sizing: border-box; }
    body { font-family: "Inter", system-ui, Arial, sans-serif; background: var(--bg); margin: 0; padding: 15px; color: #1e293b; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:14px; flex-wrap:wrap; }
    h1 { color: var(--accent); font-size: 1.25rem; margin: 0; }
    .toolbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    #searchInput { padding: 10px 12px; border-radius: 10px; border: 1px solid #d0d6df; width: 320px; font-size: 15px; outline: none; transition: 0.2s; }
    #searchInput:focus { border-color: var(--accent); box-shadow: 0 0 4px var(--accent); }
    .tableWrap { background: var(--card-bg); border-radius: 10px; padding: 10px; box-shadow: 0 8px 20px rgba(0,0,0,0.05); overflow-x: auto; }
    table { width: 100%; border-collapse: collapse; font-size: 14px; min-width: 650px; }
    th, td { padding: 10px; border-bottom: 1px solid #eef2f7; text-align: left; vertical-align: top; }
    th { background: var(--accent); color: white; text-transform: uppercase; letter-spacing: 0.03em; }
    tr.onlineRow:hover { background: #ecfdf5; } tr.offlineRow:hover { background: #fff1f1; }
    .btn { background: var(--accent); color: white; padding: 5px 5px; border-radius: 8px; border: none; cursor: pointer; }
    .btn.secondary { background: #fff; color: var(--accent); border: 1px solid #e6edf6; }
    .small { color: var(--muted); font-size: 12px; color:black; }
    .actions { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
    .pill { display:inline-block; padding:6px 8px; border-radius:999px; background:#f1f5f9; color:var(--muted); font-size:12px; margin-left:8px; }
    #mapPopup { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:9999; align-items:center; justify-content:center; }
    #mapBox { width:92%; height:82%; background:var(--card-bg); border-radius:12px; overflow:hidden; position:relative; box-shadow: 0 10px 40px rgba(0,0,0,0.25); }
    #mapHeaderBar { display:flex; align-items:center; gap:10px; padding:10px; border-bottom:1px solid #eef2f7; }
    #mapCanvas { width:100%; height:calc(100% - 56px); } /* header is ~56px */
    #closeMap { position:absolute; right:14px; top:14px; background: var(--danger); color:white; border:none; width:36px; height:36px; border-radius:50%; cursor:pointer; z-index:99999; }
    .legend { position:absolute; left:14px; bottom:14px; background:rgba(255,255,255,0.95); padding:10px; border-radius:10px; box-shadow:0 8px 20px rgba(0,0,0,0.06); font-size:13px; }
    @media (max-width:900px){ #mapBox { width:96%; height:74%; } table { min-width:600px } #searchInput { width:100%; max-width:unset } }
    .fullmap {position: right; background:#f1eeee; color:rgb(0, 0, 0); border:none; border-radius:8px; cursor:pointer; font-size:29px; }

    @media (max-width: 900px) {
  #mapBox {
    width: 96%;
    height: 74%;
  }
  table {
    min-width: 100%;
    font-size: 12px;
  }
  #searchInput {
    width: 100%;
    max-width: unset;
  }
  .btn {
    width: 100%;
    text-align: center;
  }
}
  </style>
</head>
<body>

  <!-- QR UIs (kept from your original; optional) -->
  <div class="qrcode" id="hiip" style="transform:scale(0); position:fixed; left:40%; top:12%; z-index:12000; background:white; padding:12px; border-radius:12px;">
    <div id="p"></div>
    <div style="text-align:center; margin-top:8px;">
      <button id="payclose" style="background:#f97316;color:#fff;border:none;padding:8px 12px;border-radius:10px;cursor:pointer">Close QR</button>
    </div>
  </div>

  <div class="qrcode" id="hii" style="transform:scale(0); position:fixed; left:40%; top:12%; z-index:12000; background:white; padding:12px; border-radius:12px;">
    <div id="q"></div>
    <div style="text-align:center; margin-top:8px;">
      <button id="chintuDownload" style="background:#4f46e5;color:#fff;border:none;padding:8px 12px;border-radius:10px;cursor:pointer">Download QR</button>
      <button id="cliclose" style="background:#f97316;color:#fff;border:none;padding:8px 12px;border-radius:10px;cursor:pointer;margin-left:6px">Close</button>
    </div>
  </div>

  <header>
    <div>
      <h1>Admin â€” Drivers & Live Routes</h1>
      <div class="small">Monitor drivers, open per-driver map and stream rider location (no sockets).</div>
    </div>

    <div class="toolbar">
      <input id="searchInput" placeholder="Search name, gmail or mobile" />
      <button class="btn" id="refreshBtn">Refresh</button>
      <div class="pill">Total: <span id="driverCount">0</span></div>
    </div>
  </header>

  <main class="tableWrap card">
    <table>
      <thead>
        <tr><th>Name</th><th>Status</th><th>Bookings</th><th>Actions</th></tr>
      </thead>
      <tbody id="driverTableBody">
        <tr><td colspan="6" class="small">Loading driversâ€¦</td></tr>
      </tbody>
    </table>
  </main>

  <!-- Map popup -->
  <div id="mapPopup" onclick="if(event.target === this) closeMapPopup()">
    <div id="mapBox" role="dialog" aria-modal="true">
      <div id="mapHeaderBar">
        <div id="mapHeader" class="small">Driver: â€”</div>
        <div style="flex:1"></div>
        <label class="small" style="display:flex;align-items:center;gap:8px">
          <input type="checkbox" id="streamRiderToggle" /> <span>Stream rider location</span>
        </label>
        <button id="recenterBtn" class="btn secondary" style="margin-left:8px">Recenter</button>
        <button class="fullmap" id="toggleFullscreen">â›¶</button>
      </div>

      <div id="mapCanvas"></div>
      <div class="legend"><strong>Legend:</strong><br>Green = Driver â€” Blue = Rider</div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <script>
  (function(){
    // -------------------------
    // Configuration
    // -------------------------
    const API_BASE = ""; // empty -> same origin. fill like "https://your-backend" if different.
    const POLL_DRIVERS_MS = 12_000;
    const POLL_DRIVER_MS = 3000;

    // -------------------------
    // State
    // -------------------------
    let allDrivers = [];
    let pollingTimer = null;
    let mapInstance = null;
    let driverMarker = null;
    let riderMarkers = [];
    let routeLayers = [];
    let liveWatchId = null;
    let livePollInterval = null;
    let activeDriverId = null;
    let activeRiderId = null;

    // -------------------------
    // DOM
    // -------------------------
    const driverCountEl = document.getElementById('driverCount');
    const tbody = document.getElementById('driverTableBody');
    const searchInput = document.getElementById('searchInput');
    const refreshBtn = document.getElementById('refreshBtn');
    const mapPopup = document.getElementById('mapPopup');
    const mapCanvas = document.getElementById('mapCanvas');
    const closeMapBtn = document.getElementById('closeMap');
    const mapHeader = document.getElementById('mapHeader');
    const streamToggle = document.getElementById('streamRiderToggle');
    const recenterBtn = document.getElementById('recenterBtn');

    // -------------------------
    // Helpers: normalize server responses
    // -------------------------
    function normalizeDrivers(input){
      if (!input) return [];
      if (Array.isArray(input)) return input;
      if (input.drivers && Array.isArray(input.drivers)) return input.drivers;
      if (typeof input === 'object') {
        return Object.keys(input).map(k => ({ id: k, ...(input[k] || {}) }));
      }
      return [];
    }

    // -------------------------
    // Fetch drivers list
    // -------------------------
    async function fetchDrivers(){
      try {
        const res = await fetch(API_BASE + '/showDrivers');
        const json = await res.json();
        return normalizeDrivers(json);
      } catch (e) {
        console.error('fetchDrivers error', e);
        return [];
      }
    }

    // -------------------------
    // Try to get single driver quickly
    // -------------------------
    async function getDriverById(driverId){
  // Use already fetched allDrivers first
  const driver = allDrivers.find(d => d.id === driverId);
  if (driver) return driver;

  // fallback: fetch /showDrivers again
  const res = await fetch(API_BASE + '/showDrivers');
  const json = await res.json();
  allDrivers = json.drivers || [];
  return allDrivers.find(d => d.id === driverId) || null;
}

    // -------------------------
    // Delete driver
    // -------------------------
    async function deleteDriverRemote(driverId){
      try {
        const res = await fetch(API_BASE + '/driver/' + encodeURIComponent(driverId), { method: 'DELETE' });
        if (res.ok) return true;
      } catch(e){ /* ignore */ }
      // fallback to admin endpoint
      try {
        const res2 = await fetch(API_BASE + '/admin/deleteDriver', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ id: driverId }) });
        if (res2.ok) return true;
      } catch(e){ /* ignore */ }
      return false;
    }

    // -------------------------
    // Render table rows
    // -------------------------
    async function renderTable(){
      const q = (searchInput.value || '').trim().toLowerCase();
      tbody.innerHTML = '';
      const drivers = allDrivers || [];
      let count = 0;

      for (const d of drivers){
        if (!d) continue;
        if (q) {
          const match = (d.name || '').toLowerCase().includes(q);
          if (!match) continue;
        }
        count++;
        const tr = document.createElement('tr');
        tr.className = d.online ? 'onlineRow' : 'offlineRow';

        const r1id = d.Rider1_id || '';
        const r2id = d.Rider2_id || '';

        tr.innerHTML = `
          <td>${d.name || '-'}</td>
          <td>${d.online ? 'ðŸŸ¢On' : 'ðŸ”´Off'}</td>
          <td>
            <div class="small">R1: ${r1id || '-' } â€” Code ${d.Booking1_code || '-'}</div>
            <div style="margin-top:6px" class="small">R2: ${r2id || '-' } â€” Code ${d.Booking2_code || '-'}</div>
            <div class="actions">
              <button class="btn secondary" data-driver="${d.id}" data-rider="${r1id || ''}" data-action="view-r1">View R1</button>
              <button class="btn secondary" data-driver="${d.id}" data-rider="${r2id || ''}" data-action="view-r2">View R2</button>
            </div>
          </td>
          <td>
            <div class="actions">
              <button class="btn" data-id="${d.id}" data-action="delete">Delete</button>
            </div>
          </td>
        `;
        tbody.appendChild(tr);
      }

      driverCountEl.textContent = count;

      // wire up buttons
      tbody.querySelectorAll('[data-action="view-r1"], [data-action="view-r2"]').forEach(btn=>{
        btn.onclick = () => {
          const driverId = btn.dataset.driver;
          const riderId = btn.dataset.rider || null;
          openMapForDriver(driverId, riderId);
        };
      });

      tbody.querySelectorAll('[data-action="delete"]').forEach(btn=>{
        btn.onclick = async () => {
          const id = btn.dataset.id;
          const code = prompt('Enter admin code:');
          if (code !== 'Chintu@Admin2025') { alert('Invalid code'); return; }
          if (!confirm('Delete this driver?')) return;
          const ok = await deleteDriverRemote(id);
          if (ok) { alert('Driver deleted'); await refreshDrivers(); }
          else alert('Failed to delete driver (endpoint missing or error).');
        };
      });
    }

    // -------------------------
    // Refresh/load drivers
    // -------------------------
    async function refreshDrivers(){
      allDrivers = await fetchDrivers();
      await renderTable();
    }

    // initial load + poll
    refreshDrivers();
    if (pollingTimer) clearInterval(pollingTimer);
    pollingTimer = setInterval(refreshDrivers, POLL_DRIVERS_MS);

    // wire UI
    refreshBtn.addEventListener('click', refreshDrivers);
    searchInput.addEventListener('input', renderTable);

    // -------------------------
    // Map utilities
    // -------------------------
    function cleanupMap() {
      try { if (mapInstance) mapInstance.remove(); } catch(e){}
      mapInstance = null;
      driverMarker = null;
      riderMarkers.forEach(m => m.remove()); riderMarkers = [];
      routeLayers.forEach(l => l.remove()); routeLayers = [];
      routeLayers = [];
      if (liveWatchId !== null) { navigator.geolocation.clearWatch(liveWatchId); liveWatchId = null; }
      if (livePollInterval) { clearInterval(livePollInterval); livePollInterval = null; }
      activeDriverId = null;
      activeRiderId = null;
    }

    async function getOsrmRoute(a, b){
      try {
        const url = `https://router.project-osrm.org/route/v1/driving/${a.lng},${a.lat};${b.lng},${b.lat}?overview=full&geometries=geojson`;
        const res = await fetch(url);
        const j = await res.json();
        if (!j || !j.routes || !j.routes[0]) return null;
        return j.routes[0].geometry.coordinates.map(c => ({ lat: c[1], lng: c[0] }));
      } catch (e) { console.error('OSRM error', e); return null; }
    }

    function drawRoutes(listOfCoords){
      // clear old
      routeLayers.forEach(l => l.remove());
      routeLayers = [];
      listOfCoords.forEach((coords, i) => {
        if (!coords || !coords.length) return;
        const line = L.polyline(coords, { color: i === 0 ? '#0078ff' : '#ef4444', weight: 5 }).addTo(mapInstance);
        routeLayers.push(line);
      });
    }

    async function recalcRoutes(origin, riders){
      const results = [];
      for (const r of riders){
        const coords = await getOsrmRoute(origin, r);
        results.push(coords);
      }
      drawRoutes(results);
    }

    // -------------------------
    // Open map for driver
    // -------------------------
    async function openMapForDriver(driverId, riderId){
      mapPopup.style.display = 'flex';
      cleanupMap();

      activeDriverId = driverId;
      activeRiderId = riderId;

      const driver = await getDriverById(driverId);
      if (!driver) { alert('Driver not found'); mapPopup.style.display = 'none'; return; }
      if (!driver.Driver_lat || !driver.Driver_lng) { alert('Driver has no location'); mapPopup.style.display = 'none'; return; }

      // create map
     mapInstance = L.map(mapCanvas).setView([Number(driver.Driver_lat), Number(driver.Driver_lng)], 14);
     // OpenStreetMap (default street map)
const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(mapInstance); // add as default

// Satellite / World Image layer
const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/' +
  'World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, Maxar, USGS',
  maxZoom: 19
});
const baseMaps = {
  "Street Map": osmLayer,
  "Satellite": satelliteLayer
};

L.control.layers(baseMaps).addTo(mapInstance);


      driverMarker = L.marker([Number(driver.Driver_lat), Number(driver.Driver_lng)], { title: 'Driver' }).addTo(mapInstance);

      const riderPoints = [];
      if (driver.Rider1_lat && driver.Rider1_lng) riderPoints.push({ lat: Number(driver.Rider1_lat), lng: Number(driver.Rider1_lng), id: driver.Rider1_id, label: 'Rider 1' });
      if (driver.Rider2_lat && driver.Rider2_lng) riderPoints.push({ lat: Number(driver.Rider2_lat), lng: Number(driver.Rider2_lng), id: driver.Rider2_id, label: 'Rider 2' });

      riderMarkers = riderPoints.map(r => L.marker([r.lat, r.lng], { title: r.label }).addTo(mapInstance));
      if (riderPoints.length) await recalcRoutes({ lat: Number(driver.Driver_lat), lng: Number(driver.Driver_lng) }, riderPoints);

      mapHeader.textContent = `Driver: ${driver.name || driverId} â€” ${driver.mobile || ''}`;

      // start polling driver node for updates
      if (livePollInterval) clearInterval(livePollInterval);
      livePollInterval = setInterval(async () => {
        const latest = await getDriverById(driverId);
        if (!latest) return;
        if (latest.Driver_lat && latest.Driver_lng) {
          const latN = Number(latest.Driver_lat);
          const lngN = Number(latest.Driver_lng);
          driverMarker.setLatLng([latN, lngN]);
          // update rider markers
          const pts = [];
          if (latest.Rider1_lat && latest.Rider1_lng) pts.push({ lat: Number(latest.Rider1_lat), lng: Number(latest.Rider1_lng), id: latest.Rider1_id });
          if (latest.Rider2_lat && latest.Rider2_lng) pts.push({ lat: Number(latest.Rider2_lat), lng: Number(latest.Rider2_lng), id: latest.Rider2_id });

          riderMarkers.forEach(m => m.remove());
          riderMarkers = pts.map(p => L.marker([p.lat, p.lng]).addTo(mapInstance));

          if (pts.length) recalcRoutes({ lat: latN, lng: lngN }, pts);
        }
      }, POLL_DRIVER_MS);

      // stream toggle handler
      streamToggle.checked = false;
      streamToggle.onchange = async () => {
        if (!streamToggle.checked) {
          if (liveWatchId !== null) { navigator.geolocation.clearWatch(liveWatchId); liveWatchId = null; }
          return;
        }
        if (!activeRiderId) { alert('No rider selected to stream location for.'); streamToggle.checked = false; return; }
        if (!navigator.geolocation) { alert('Geolocation not supported'); streamToggle.checked = false; return; }

        // watch and POST to /riderLocation
        liveWatchId = navigator.geolocation.watchPosition(async pos => {
          const lat = pos.coords.latitude, lng = pos.coords.longitude;
          try {
            await fetch(API_BASE + '/riderLocation', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ riderId: activeRiderId, lat, lng })
            });
          } catch (e) { console.error('stream error', e); }
        }, err => { console.error('geolocation watch error', err); }, { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 });
      };

      recenterBtn.onclick = () => {
        if (driverMarker && mapInstance) mapInstance.setView(driverMarker.getLatLng(), 15);
      };
    }

    // -------------------------
    // Close popup
    // -------------------------
    function closeMapPopup(){
      mapPopup.style.display = 'none';
      cleanupMap();
    }

    // expose functions to global (if needed)
    window.openMapForDriver = openMapForDriver;
    window.closeMapPopup = closeMapPopup;

    // initial load
    (async function init(){
      allDrivers = await fetchDrivers();
      await renderTable();
      setInterval(async ()=>{
        allDrivers = await fetchDrivers();
        await renderTable();
      }, POLL_DRIVERS_MS);
    })();

  })();

   document.addEventListener('click', e => {
    if (e.target.id === 'toggleFullscreen') {
      const el = document.getElementById('mapBox');
      if (!document.fullscreenElement) { el.requestFullscreen().catch(err => console.error(err)); } else { document.exitFullscreen(); }
    }
  });

  </script>
</body>
</html>
